/**
 * ColorLCDShield.ino
 * RTno is RT-middleware and arduino.
 *
 * @author Yuki Suga
 * This code is written/distributed for public-domain.
 * 
 * ColorLCDShield sample.
 * 
 * Use arduino-MEGA 2560 + Sparkfun ColorLCD shield
 * http://www.arduino.cc/en/Main/ArduinoBoardMega2560
 * http://www.sparkfun.com/products/9363
 * (I do not recommend you to use arduino Uno and other 
 * arduinos which use AT-mega 328 series, because their
 * program memory is too small for Color LCD shield to 
 * use.)
 *
 * OutPort: TimedLongSeq button inputs.
 * InPort : TimedFloatSeq RGB color. (all elements are 0-1.0 value).
 *
 * ColorLCDShield Library can be downloaded in
 * http://github.com/ysuga/ColorLCDShield
 * ** This library is originally developed by Jim Lindblom @ Sparkfun
 * which is distributed under the terms of Creative commons share-alike 3.0
 * 
 */
#include <UART.h>
#include <RTno.h>
#include <ColorLCDShield.h>

/**
 * This function is called at first.
 * conf._default.baudrate: baudrate of serial communication
 * exec_cxt.periodic.type: reserved but not used.
 */
void rtcconf(config_str& conf, exec_cxt_str& exec_cxt) {
  conf._default.connection_type = ConnectionTypeSerial1;
  conf._default.baudrate = 57600;
  exec_cxt.periodic.type = ProxySynchronousExecutionContext;
}

TimedFloatSeq in0;
InPort<TimedFloatSeq> in0In("rgb", in0);

TimedLongSeq out0;
OutPort<TimedLongSeq> out0Out("out0", out0);

LCDShield lcd;
int buttonPins[3] = {3, 4, 5};


int logo_color = BLUE;

char rt_logo[1120] = {
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xc0,0x00,0x00,0x00,0x00,0xff,0xf0,0x00,0x00,0x00,0x00,0x00,0x3f,0xff,
0xff,0xff,0x80,0x00,0x00,0x00,0x00,0x3f,0xe0,0x00,0x00,0x00,0x00,0x00,0x3f,0xff,
0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x1f,0xe0,0x00,0x00,0x00,0x00,0x00,0x1f,0xff,
0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x1f,0xe0,0x00,0x00,0x00,0x00,0x00,0x1f,0xff,
0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x0f,0xe0,0x00,0x00,0x00,0x00,0x00,0x1f,0xff,
0xff,0xff,0x80,0x00,0x00,0x00,0x00,0x0f,0xe0,0x00,0x00,0x00,0x00,0x00,0x3f,0xff,
0xff,0xff,0xc0,0x00,0x00,0x00,0x00,0x0f,0xf0,0x00,0x00,0x00,0x00,0x00,0x3f,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xc0,0x0f,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xe0,0x0f,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0x80,0x0f,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xfe,0x00,0x0f,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xfc,0x00,0x1f,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xf0,0x00,0x1f,0xff,0xff,0xff,0x87,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xc0,0x00,0x3f,0xff,0xff,0xff,0x03,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0x80,0x00,0xff,0xff,0xff,0xfe,0x01,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xfe,0x00,0x01,0xff,0xff,0xff,0xfe,0x01,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xf8,0x00,0x07,0xff,0xff,0xff,0xfe,0x01,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xe0,0x00,0x1f,0xff,0xff,0xff,0xfe,0x01,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xc0,0x00,0x7f,0xff,0xff,0xff,0xfe,0x01,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0x00,0x00,0xff,0xff,0xff,0xff,0xfe,0x01,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xfc,0x00,0x03,0xff,0xff,0xff,0xff,0xfe,0x01,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xf0,0x00,0x0f,0xff,0xff,0xff,0xff,0xfe,0x01,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xe0,0x00,0x3f,0xff,0xff,0xff,0xff,0xfe,0x01,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0x80,0x00,0x7f,0xff,0xff,0xff,0xff,0xfe,0x01,0xff,0xff,0xff,0xff,
0xff,0xff,0xfe,0x00,0x01,0xff,0xff,0xff,0xff,0xff,0xfe,0x01,0xff,0xff,0xff,0xff,
0xff,0xff,0xfc,0x00,0x07,0xfc,0xff,0xff,0xff,0xff,0xfe,0x01,0xff,0xff,0xff,0xff,
0xff,0xff,0xf8,0x00,0x1f,0xf0,0x3f,0xff,0xff,0xff,0xfe,0x01,0xff,0xff,0xff,0xff,
0xff,0xff,0xf0,0x00,0x3f,0xf0,0x1f,0xff,0xff,0xff,0xfe,0x01,0xff,0xff,0xff,0xff,
0xff,0xff,0xf0,0x00,0xff,0xe0,0x0f,0xff,0xff,0xff,0xfe,0x01,0xff,0xff,0xff,0xff,
0xff,0xff,0xf0,0x03,0xff,0xe0,0x07,0xff,0xff,0xff,0xfe,0x01,0xff,0xff,0xff,0xff,
0xff,0xff,0xf0,0x07,0xff,0xf0,0x07,0xff,0xff,0xff,0xfe,0x01,0xff,0xff,0xff,0xff,
0xff,0xff,0xf0,0x0f,0xff,0xf0,0x03,0xff,0xff,0xff,0xfe,0x01,0xff,0xff,0xff,0xff,
0xff,0xff,0xf0,0x0f,0xff,0xf8,0x01,0xff,0xff,0xff,0xfe,0x01,0xff,0xff,0xff,0xff,
0xff,0xff,0xf0,0x0f,0xff,0xfc,0x00,0xff,0xff,0xff,0xfe,0x01,0xff,0xff,0xff,0xff,
0xff,0xff,0xf0,0x0f,0xff,0xfc,0x00,0x7f,0xff,0xff,0xfe,0x01,0xff,0xff,0xff,0xff,
0xff,0xff,0xf0,0x0f,0xff,0xfe,0x00,0x3f,0xff,0xff,0xfe,0x01,0xff,0xff,0xff,0xff,
0xff,0xff,0xf0,0x0f,0xff,0xff,0x00,0x1f,0xff,0xff,0xfe,0x01,0xff,0xff,0xff,0xff,
0xff,0xff,0xf0,0x0f,0xff,0xff,0x80,0x1f,0xff,0xff,0xfe,0x01,0xff,0xff,0xff,0xff,
0xff,0xff,0xf0,0x0f,0xff,0xff,0xc0,0x0f,0xff,0xff,0xfe,0x01,0xff,0xff,0xff,0xff,
0xff,0xff,0xf0,0x0f,0xff,0xff,0xe0,0x07,0xff,0xff,0xfe,0x01,0xff,0xff,0xff,0xff,
0xff,0xff,0xf0,0x0f,0xff,0xff,0xe0,0x03,0xff,0xff,0xfe,0x01,0xff,0xff,0xff,0xff,
0xff,0xff,0xf0,0x0f,0xff,0xff,0xf0,0x01,0xff,0xff,0xfe,0x01,0xff,0xff,0xff,0xff,
0xff,0xff,0xf0,0x0f,0xff,0xff,0xf8,0x00,0xff,0xff,0xfe,0x01,0xff,0xff,0xff,0xff,
0xff,0xff,0xf0,0x0f,0xff,0xff,0xfc,0x00,0xff,0xff,0xfe,0x01,0xff,0xff,0xff,0xff,
0xff,0xff,0xf0,0x0f,0xff,0xff,0xfe,0x00,0x7f,0xff,0xfe,0x01,0xff,0xff,0xff,0xff,
0xff,0xff,0xf0,0x0f,0xff,0xff,0xff,0x00,0x3f,0xff,0xfe,0x01,0xff,0xff,0xff,0xff,
0xff,0xff,0xf0,0x0f,0xff,0xff,0xff,0x80,0x1f,0xff,0xfe,0x01,0xff,0xff,0xff,0xff,
0xff,0xff,0xf0,0x0f,0xff,0xff,0xff,0x80,0x1f,0xff,0xfe,0x01,0xff,0xff,0xff,0xff,
0xff,0xff,0xf0,0x0f,0xff,0xff,0xff,0xc0,0x1f,0xff,0xfe,0x01,0xff,0xff,0xff,0xff,
0xff,0xff,0xf8,0x0f,0xff,0xff,0xff,0xe0,0x3f,0xff,0xfe,0x03,0xff,0xff,0xff,0xff,
0xff,0xff,0xf8,0x1f,0xff,0xff,0xff,0xf0,0x3f,0xff,0xff,0x03,0xff,0xff,0xff,0xff,
0xff,0xff,0xfe,0x7f,0xff,0xff,0xff,0xfc,0xff,0xff,0xff,0xcf,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xfe,0xff,0x3d,0xe0,0x7f,0x03,0xfb,0xff,0x00,0x6f,0xcf,0xbf,0x3f,0x80,0xfc,0x03,
0xfc,0x3e,0x39,0xc0,0x0e,0x00,0x79,0xff,0x00,0x67,0x87,0x1e,0x1f,0x80,0x38,0x01,
0xfc,0x3c,0x39,0xcf,0xc7,0x3e,0x39,0xff,0x3f,0xe3,0x87,0x3e,0x1f,0x9f,0x98,0xff,
0xfc,0x1c,0x39,0xcf,0xe7,0x3f,0x39,0xff,0x3f,0xf3,0x07,0x3c,0x8f,0x9f,0x18,0xff,
0xfc,0x89,0x39,0xcf,0xe7,0x3f,0x39,0xff,0x01,0xf1,0x32,0x78,0xcf,0x80,0x38,0x0f,
0xfc,0xc3,0x39,0xcf,0xe7,0x3f,0x39,0xff,0x3f,0xf8,0x70,0x78,0x07,0x9c,0x78,0xff,
0xfc,0xe7,0x39,0xcf,0xc7,0x3e,0x39,0xff,0x3f,0xf8,0x78,0xf0,0x03,0x9e,0x79,0xff,
0xfc,0xe7,0x39,0xc0,0x0e,0x00,0x78,0x03,0x00,0x7c,0x78,0xf3,0xf3,0x9f,0x38,0x01,
0xfe,0xff,0x3d,0xe0,0x3f,0x01,0xf8,0x03,0x00,0x7c,0xfd,0xf7,0xf3,0x9f,0xbc,0x01,
};


void printRTLogo(int color)
{
  int x = 2, y = 5, logo_ix = 0, z;
  char logo;
  for (logo_ix = 0; logo_ix < 1120; logo_ix++) {
    logo = rt_logo[logo_ix];
    for (z = 0; z < 8; z++) {
      if ((logo & 0x80) != 0x80) {
        lcd.setPixel(color, y, x);
      }
      x++;
      if (x == 130) {
        x = 2;
        y++;
      }
      logo <<= 1;
    }
  }
}


//////////////////////////////////////////
// on_initialize
//
// This function is called in the initialization
// sequence. The sequence is triggered by the
// PC. When the RTnoRTC is launched in the PC,
// then, this function is remotely called
// through the USB cable.
// In on_initialize, usually DataPorts are added.
//
//////////////////////////////////////////
int RTno::onInitialize() {
  lcd.init(PHILLIPS);
  lcd.contrast(30);
  lcd.clear(BLACK);
  printRTLogo(WHITE);

  /* Data Ports are added in this section. */
  addInPort(in0In);
  addOutPort(out0Out);
  
  for(int i = 0;i < 3;i++) {
    pinMode(buttonPins[i], INPUT);
    digitalWrite(buttonPins[i], HIGH);// pull up
  } 

  delay(100);
  printRTLogo(BLUE);
  lcd.setStr("Initialized", 80, 00, BLUE, BLACK);
  return RTC_OK; 
}

////////////////////////////////////////////
// on_activated
// This function is called when the RTnoRTC
// is activated. When the activation, the RTnoRTC
// sends message to call this function remotely.
// If this function is failed (return value 
// is RTC_ERROR), RTno will enter ERROR condition.
////////////////////////////////////////////
int RTno::onActivated() {
  // Write here initialization code.
  printRTLogo(GREEN);
  lcd.setStr("Activated   ", 80, 0, GREEN, BLACK);
  logo_color = GREEN;
  return RTC_OK; 
}

/////////////////////////////////////////////
// on_deactivated
// This function is called when the RTnoRTC
// is deactivated.
/////////////////////////////////////////////
int RTno::onDeactivated()
{
  // Write here finalization code.
  printRTLogo(BLUE);
  lcd.setStr("Dectivated   ", 80, 0, BLUE, BLACK);
  return RTC_OK;
}

//////////////////////////////////////////////
// This function is repeatedly called when the 
// RTno is in the ACTIVE condition.
// If this function is failed (return value is
// RTC_ERROR), RTno immediately enter into the 
// ERROR condition.
//////////////////////////////////////////////
int RTno::onExecute() {

  if(in0In.isNew()) {
    in0In.read();
    double r = in0.data[0];
    double g = in0.data[1];
    double b = in0.data[2];

    if(r > 1)  r = 1.0; else if(r < 0) r = 0.0;
    if(g > 1)  g = 1.0; else if(g < 0) g = 0.0;
    if(b > 1)  b = 1.0; else if(b < 0) b = 0.0;
    

    char br = (char)(0x0f * r);
    char bg = (char)(0x0f * g);
    char bb = (char)(0x0f * b);
    
    logo_color = bb << 8 | bg << 4 | br;
    printRTLogo(logo_color);
  }
  
  /**
   * Send Button Datas
   */
  out0.data.length(3);
  for(int i = 0;i < 3;i++) { 
    out0.data[i] = digitalRead(buttonPins[i]);
  }
  out0Out.write();
    
  return RTC_OK; 
}


//////////////////////////////////////
// on_error
// This function is repeatedly called when
// the RTno is in the ERROR condition.
// The ERROR condition can be recovered,
// when the RTno is reset.
///////////////////////////////////////
int RTno::onError()
{
  return RTC_OK;
}

////////////////////////////////////////
// This function is called when 
// the RTno is reset. If on_reset is
// succeeded, the RTno will enter into
// the INACTIVE condition. If failed 
// (return value is RTC_ERROR), RTno
// will stay in ERROR condition.ec
///////////////////////////////////////
int RTno::onReset()
{
  return RTC_OK;
}


